using Content.Client._COYOTE.Helpers;
using Content.Client.UserInterface.Systems.Chat.Controls;
using Content.Shared._EE.CCVars; // EE - chat stacking
using Content.Shared.CCVar;
using Content.Shared.Chat;
using Content.Shared.Input;
using Robust.Client.Audio;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Audio;
using Robust.Shared.Configuration;
using Robust.Shared.Input;
using Robust.Shared.Player;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using System.Linq;
using static Robust.Client.UserInterface.Controls.TextEdit;

namespace Content.Client.UserInterface.Systems.Chat.Widgets;

[GenerateTypedNameReferences]
[Virtual]
public partial class ChatBox : UIWidget
{
    private readonly ChatUIController _controller;
    private readonly IEntityManager _entManager;
    [Dependency] private readonly IConfigurationManager _cfg = default!; // EE - Chat stacking
    [Dependency] private readonly ILocalizationManager _loc = default!; // EE - Chat stacking

    public bool Main { get; set; }

    public ChatSelectChannel SelectedChannel => ChatInput.ChannelSelector.SelectedChannel;

    // EE - Chat stacking
    private int _chatStackAmount = 0;
    private bool ChatStackEnabled => _chatStackAmount > 0;
    private List<ChatStackData> _chatStackList;
    // End EE - Chat stacking

    private List<Rope.Node> _chatHistory = new();
    private int _historyPosition = 0;
    private const int MaxHistorySize = 100;
    private bool _focused = false;

    public ChatBox()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _entManager = IoCManager.Resolve<IEntityManager>();

        ChatInput.Input.OnKeyBindDown += OnInputKeyBindDown;
        ChatInput.Input.OnTextChanged += OnTextChanged;
        ChatInput.ChannelSelector.OnChannelSelect += OnChannelSelect;
        ChatInput.FilterButton.Popup.OnChannelFilter += OnChannelFilter;
        ChatInput.FilterButton.Popup.OnNewHighlights += OnNewHighlights;
        _cfg.OnCVarValueChanged += OnConfigUpdated;
        _controller = UserInterfaceManager.GetUIController<ChatUIController>();
        _controller.MessageAdded += OnMessageAdded;
        _controller.HighlightsUpdated += OnHighlightsUpdated;
        _controller.RegisterChat(this);

        // EE - Chat stacking
        _chatStackList = new List<ChatStackData>(_chatStackAmount);
        _cfg.OnValueChanged(EECVars.ChatStackLastLines, UpdateChatStack, true);
        // End EE - Chat stacking
    }

    // Keep the typing indicator synced
    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);
        if (!ChatInput.Input.HasKeyboardFocus())
        {
            SetChatFocused(false);
        }
        else
        {
            SetChatFocused(true);
        }
    }

    private void SetChatFocused(bool focused)
    {
        if (focused != _focused)
        {
            _controller.NotifyChatFocus(focused);
            _focused = focused;
        }
    }

    private void OnConfigUpdated(CVarChangeInfo info)
    {
        if (info.Name == "ui.chat-lines")
        {
            SetInputHeight();
        }
    }

    // EE - Chat stacking
    private void UpdateChatStack(int value)
    {
        _chatStackAmount = value >= 0 ? value : 0;
        Repopulate();
    }

    private void OnMessageAdded(ChatMessage msg)
    {
        Logger.DebugS("chat", $"{msg.Channel}: {msg.Message}");
        if (!ChatInput.FilterButton.Popup.IsActive(msg.Channel))
        {
            return;
        }

        if (msg is { Read: false, AudioPath: { } })
            _entManager.System<AudioSystem>().PlayGlobal(msg.AudioPath, Filter.Local(), false, AudioParams.Default.WithVolume(msg.AudioVolume));

        msg.Read = true;

        var color = msg.MessageColorOverride ?? msg.Channel.TextColor();


        // EE - Chat stacking
        var index = _chatStackList.FindIndex(data => data.Channel == msg.Channel && data.Entity == msg.SenderEntity && data.Message == msg.Message); // Frontier: add entity, channel, use message, not wrapped message

        if (index == -1) // this also handles chatstack being disabled, since FindIndex won't find anything in an empty array
        {
            TrackNewMessage(msg.WrappedMessage, color, msg.Message, msg.SenderEntity, msg.Channel); // Frontier: add Message, SenderEntity
            AddLine(msg.WrappedMessage, color);
            return;
        }

        UpdateRepeatingLine(index);
        // End EE - Chat stacking
    }

    /// <summary>
    /// Removing and then adding instantly nudges the chat window up before slowly dragging it back down, which makes the whole chat log shake.
    /// With rapid enough updates, the whole chat becomes unreadable.
    /// Adding first and then removing does not produce any visual effects.
    /// The other option is to duplicate OutputPanel functionality and everything internal to the engine it relies on.
    /// But OutputPanel relies on directly setting Control.Position for control embedding. (which is not exposed to Content.)
    /// Thanks robustengine, very cool.
    /// </summary>
    /// <remarks>
    /// zero index is the very last line in chat, 1 is the line before the last one, 2 is the line before that, etc.
    /// </remarks>
    // EE - Chat stacking
    private void UpdateRepeatingLine(int index)
    {
        _chatStackList[index].RepeatCount++;
        for (var i = index; i >= 0; i--)
        {
            var data = _chatStackList[i];
            AddLine(data.WrappedMessage, data.ColorOverride, data.RepeatCount);
            Contents.RemoveEntry(Index.FromEnd(index + 2));
        }
    }

    // EE - Chat stacking
    private void TrackNewMessage(string wrappedMessage, Color colorOverride, string message, NetEntity entity, ChatChannel channel) // Frontier: add message, entity, channel
    {
        if (!ChatStackEnabled)
            return;

        if (_chatStackList.Count == _chatStackList.Capacity)
            _chatStackList.RemoveAt(_chatStackList.Capacity - 1);

        _chatStackList.Insert(0, new ChatStackData(wrappedMessage, colorOverride, message, entity, channel)); // Frontier: add message, entity, channel
    }

    private void OnHighlightsUpdated(string highlights)
    {
        ChatInput.FilterButton.Popup.UpdateHighlights(highlights);
    }

    private void OnChannelSelect(ChatSelectChannel channel)
    {
        _controller.UpdateSelectedChannel(this);
    }

    public void Repopulate()
    {
        Contents.Clear();
        _chatStackList = new List<ChatStackData>(_chatStackAmount); // EE - Chat stacking
        foreach (var message in _controller.History)
        {
            OnMessageAdded(message.Item2);
        }
    }

    private void OnChannelFilter(ChatChannel channel, bool active)
    {
        Contents.Clear();

        foreach (var message in _controller.History)
        {
            OnMessageAdded(message.Item2);
        }

        if (active)
        {
            _controller.ClearUnfilteredUnreads(channel);
        }
    }

    private void OnNewHighlights(string highlighs)
    {
        _controller.UpdateHighlights(highlighs);
    }

    public void AddLine(string message, Color color, int repeat = 0) // EE - Chat stacking - repeat
    {
        var formatted = new FormattedMessage(4); // EE - Chat stacking - up from 3
        formatted.PushColor(color);
        formatted.AddMarkupOrThrow(message);
        formatted.Pop();

        // EE - Chat stacking
        if (repeat != 0)
        {
            var displayRepeat = repeat + 1;
            var sizeIncrease = Math.Min(displayRepeat / 6, 5);
            formatted.AddMarkupOrThrow(_loc.GetString("chat-system-repeated-message-counter",
                                ("count", displayRepeat),
                                ("size", 8 + sizeIncrease)
                                ));
        }
        // End EE - Chat stacking

        Contents.AddMessage(formatted);
    }

    public void Focus(ChatSelectChannel? channel = null)
    {
        var input = ChatInput.Input;
        var selectStart = Index.End;

        if (channel != null)
            ChatInput.ChannelSelector.Select(channel.Value);

        input.GrabKeyboardFocus();

        input.CursorPosition = new CursorPos(input.TextLength, LineBreakBias.Bottom);
        input.SelectionStart = new CursorPos(selectStart.GetOffset(input.TextLength), LineBreakBias.Bottom);
    }

    public void CycleChatChannel(bool forward)
    {
        var idx = Array.IndexOf(ChannelSelectorPopup.ChannelSelectorOrder, SelectedChannel);
        do
        {
            // go over every channel until we find one we can actually select.
            idx += forward ? 1 : -1;
            idx = MathHelper.Mod(idx, ChannelSelectorPopup.ChannelSelectorOrder.Length);
        } while ((_controller.SelectableChannels & ChannelSelectorPopup.ChannelSelectorOrder[idx]) == 0);

        SafelySelectChannel(ChannelSelectorPopup.ChannelSelectorOrder[idx]);
    }

    public void SafelySelectChannel(ChatSelectChannel toSelect)
    {
        toSelect = _controller.MapLocalIfGhost(toSelect);
        if ((_controller.SelectableChannels & toSelect) == 0)
            return;

        ChatInput.ChannelSelector.Select(toSelect);
    }

    private void OnInputKeyBindDown(GUIBoundKeyEventArgs args)
    {
        if (args.Function == EngineKeyFunctions.TextReleaseFocus)
        {
            ChatInput.Input.ReleaseKeyboardFocus();
            ChatInput.Input.TextRope = new Rope.Leaf("");
            args.Handle();
            return;
        }

        // Fix bug with robust delete that prevents it from being used at the end of line
        if (args.Function == EngineKeyFunctions.TextWordBackspace && ChatInput.Input.CursorPosition.Index == ChatInput.Input.TextLength)
        {
            var runes = Rope.EnumerateRunesReverse(ChatInput.Input.TextRope, ChatInput.Input.CursorPosition.Index);
            int remAmt = -TextEditHelpers.PrevWordPosition(runes.GetEnumerator());

            ChatInput.Input.TextRope = Rope.Delete(ChatInput.Input.TextRope, ChatInput.Input.CursorPosition.Index - remAmt, remAmt);
            ChatInput.Input.CursorPosition = new CursorPos(ChatInput.Input.CursorPosition.Index - remAmt, LineBreakBias.Bottom);
            SetInputHeight();
        }

        if (args.Function == EngineKeyFunctions.MultilineTextSubmit)
        {
            ChatInput.Input.InsertAtCursor("\n");
            args.Handle();
            return;
        }
        else if (args.Function == EngineKeyFunctions.TextSubmit)
        {
            Submit();
            args.Handle();
            return;
        }

        if (args.Function == EngineKeyFunctions.TextCursorUp && HistoryUp())
        {
            args.Handle();
            return;
        }

        if (args.Function == EngineKeyFunctions.TextCursorDown && HistoryDown())
        {
            args.Handle();
            return;
        }

        if (args.Function == ContentKeyFunctions.CycleChatChannelForward)
        {
            CycleChatChannel(true);
            args.Handle();
            return;
        }

        if (args.Function == ContentKeyFunctions.CycleChatChannelBackward)
        {
            CycleChatChannel(false);
            args.Handle();
        }
    }

    public void Submit()
    {
        SaveHistoryRecord();
        _historyPosition = 0;
        _controller.SendMessage(this, SelectedChannel);
    }

    private bool SaveHistoryRecord()
    {
        var text = Rope.Collapse(ChatInput.Input.TextRope);
        // Don't save duplicate history entries
        if (text.Length > 0 && text != Rope.Collapse(_chatHistory.LastOrDefault() ?? new Rope.Leaf("")))
        {
            _chatHistory.Add(ChatInput.Input.TextRope);
            _historyPosition = 0;

            if (_chatHistory.Count > MaxHistorySize)
            {
                _chatHistory.RemoveAt(0);
            }
            return true;
        }

        return false;
    }

    private bool HistoryUp()
    {
        var lines = GetLineBreaks(out var cursorLine);

        // If the cursor is at the top of the box, go up in history
        if (cursorLine == 1)
        {
            // If we're not in the midst of history, save our current text so we can get back to it
            if (_historyPosition == 0 && SaveHistoryRecord())
            {
                _historyPosition = 1;
            }

            _historyPosition++;

            if (_chatHistory.Count - _historyPosition >= 0)
            {
                // Restore the N-th history item from the end
                ChatInput.Input.TextRope = _chatHistory[_chatHistory.Count - _historyPosition];
                ChatInput.Input.CursorPosition = new CursorPos(ChatInput.Input.TextLength, LineBreakBias.Bottom);

                SetInputHeight();

                return true;
            }
            else
            {
                _historyPosition = _chatHistory.Count;
                return false;
            }
        }
        return false;
    }

    private bool HistoryDown()
    {
        var lines = GetLineBreaks(out var cursorLine);

        // If the cursor is at the bottom of the box, go down in history
        if (cursorLine == lines)
        {
            if (--_historyPosition > 0)
            {
                // Restore the N-th history item from the end
                ChatInput.Input.TextRope = _chatHistory[_chatHistory.Count - _historyPosition];
                ChatInput.Input.CursorPosition = new CursorPos(ChatInput.Input.TextLength, LineBreakBias.Bottom);

                SetInputHeight();
                ChatInput.Input.GrabKeyboardFocus(); // Force textbox to update scroll position

                return true;
            }
            else
            {
                // Save our current text so we can get back to it
                SaveHistoryRecord();
                // No more history, to clear the textbox
                ChatInput.Input.TextRope = new Rope.Leaf("");
                ChatInput.Input.SetHeight = 22;
                _historyPosition = 0;
                return false;
            }
        }

        return false;
    }

    private void SetInputHeight()
    {
        int maxLines = _cfg.GetCVar(CCVars.ChatLines);

        var height = 22 * Math.Min(GetLineBreaks(), maxLines);
        if ((int)ChatInput.Height != height)
        {
            ChatInput.Input.SetHeight = height;
        }
    }

    private void OnTextChanged(TextEditEventArgs args)
    {
        // Update channel select button to correct channel if we have a prefix.
        _controller.UpdateSelectedChannel(this);

        SetInputHeight();

        // Warn typing indicator about change
        _controller.NotifyChatTextChange();
    }

    private int GetLineBreaks()
    {
        return GetLineBreaks(out var _);
    }

    private int GetLineBreaks(out int cursorLine)
    {
        var font = StylePropertyDefault("font", UserInterfaceManager.ThemeDefaults.DefaultFont);
        var scale = UIScale;

        var cursorRune = ChatInput.Input.CursorPosition.Index;

        var wordWrap = new WordWrapHelper(ChatInput.Input.PixelWidth);
        int? breakLine;
        int lines = 1;
        int currentRune = 0;
        int currentWordStart = 0;
        cursorLine = 1;

        foreach (var rune in Rope.EnumerateRunes(ChatInput.Input.TextRope))
        {
            var oldLines = lines;
            currentRune++;
            // Check for line breaks
            wordWrap.NextRune(rune, out breakLine, out var breakNewLine, out var skip, out var isWordBoundry);
            lines += CheckLineBreak(breakLine);
            lines += CheckLineBreak(breakNewLine);

            if (!skip && font.TryGetCharMetrics(rune, scale, out var metrics))
            {
                wordWrap.NextMetrics(metrics, out breakLine, out var abort);
                lines += CheckLineBreak(breakLine);
            }

            // Record the start of a word
            if (isWordBoundry)
            {
                currentWordStart = currentRune;
            }

            // Update the cursor position
            if (currentRune == cursorRune)
            {
                cursorLine = lines;
            }

            // When a line breaks, check if the cursor was in the part that got pushed down
            if (oldLines != lines && cursorRune >= currentWordStart - (ChatInput.Input.CursorPosition.Bias == LineBreakBias.Bottom ? 1 : 0) && cursorRune <= currentRune)
            {
                // The cursor got pushed to the new line
                cursorLine = lines;
            }
        }

        wordWrap.FinalizeText(out breakLine);
        lines += CheckLineBreak(breakLine);

        // If our cursor is on the last word (or just before it), recheck in case the last word wrapped
        if (cursorRune >= currentWordStart - (ChatInput.Input.CursorPosition.Bias == LineBreakBias.Bottom ? 1 : 0) && cursorRune <= currentRune)
        {
            cursorLine = lines;
        }

        return lines;

        int CheckLineBreak(int? line)
        {
            if (line is { } l)
            {
                return 1;
            }
            return 0;
        }
    }

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);

        if (!disposing) return;
        _controller.UnregisterChat(this);
        ChatInput.Input.OnKeyBindDown -= OnInputKeyBindDown;
        ChatInput.Input.OnTextChanged -= OnTextChanged;
        ChatInput.ChannelSelector.OnChannelSelect -= OnChannelSelect;
        _cfg.UnsubValueChanged(EECVars.ChatStackLastLines, UpdateChatStack); // EE - Chat stacking
        //Updater.Dispose();
    }

    // EE - Chat stacking
    private sealed class ChatStackData
    {
        public NetEntity Entity; // Frontier: speaker
        public string Message; // Frontier: base message
        public ChatChannel Channel; // Frontier: channel
        public string WrappedMessage;
        public Color ColorOverride;
        public int RepeatCount = 0;
        public ChatStackData(string wrappedMessage, Color colorOverride, string message, NetEntity entity, ChatChannel channel)
        {
            WrappedMessage = wrappedMessage;
            ColorOverride = colorOverride;
            Message = message; // Frontier
            Entity = entity; // Frontier
            Channel = channel; // Frontier
        }
    }
    // End EE - Chat stacking
}
